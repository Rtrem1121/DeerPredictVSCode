#!/usr/bin/env python3
"""
Comprehensive test script to validate deer prediction algorithms and logical consistency.
Tests real Vermont locations and verifies that results make sense.
"""

import requests
import json
from datetime import datetime, time
import sys
import os

# Add backend to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

def test_api_endpoint(lat, lon, season="rut", date_time="2023-11-15T07:00:00"):
    """Test the prediction API endpoint"""
    url = "http://localhost:8000/predict"
    
    payload = {
        "lat": lat,
        "lon": lon,
        "date_time": date_time,
        "season": season
    }
    
    try:
        response = requests.post(url, json=payload, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            print(f"API Error {response.status_code}: {response.text}")
            return None
    except requests.exceptions.RequestException as e:
        print(f"Connection error: {e}")
        return None

def validate_prediction_logic(prediction, location_name):
    """Validate that prediction results are logically consistent"""
    print(f"\nüéØ Testing: {location_name}")
    
    if not prediction:
        print("‚ùå No prediction data received")
        return False
    
    # Test 1: Stand rating should be between 0-10
    stand_rating = prediction.get('stand_rating', 0)
    if not (0 <= stand_rating <= 10):
        print(f"‚ùå Stand rating {stand_rating} is outside valid range (0-10)")
        return False
    print(f"‚úÖ Stand rating: {stand_rating}/10")
    
    # Test 2: Check that we have core prediction components
    required_components = ['five_best_stands', 'hunt_schedule', 'stand_rating', 'notes']
    for component in required_components:
        if component not in prediction:
            print(f"‚ùå Missing required component: {component}")
            return False
    print("‚úÖ All required components present")
    
    # Test 3: Validate 5 best stands
    best_stands = prediction.get('five_best_stands', [])
    if len(best_stands) == 0:
        print("‚ö†Ô∏è No stand recommendations generated")
    else:
        print(f"‚úÖ Generated {len(best_stands)} stand recommendations")
        
        for i, stand in enumerate(best_stands):
            # Check confidence is reasonable
            confidence = stand.get('confidence', 0)
            if not (0 <= confidence <= 100):
                print(f"‚ùå Stand {i+1} confidence {confidence} is invalid")
                return False
            
            # Check that coordinates are present
            coords = stand.get('coordinates', {})
            if 'lat' not in coords or 'lon' not in coords:
                print(f"‚ùå Stand {i+1} missing coordinates")
                return False
        
        print(f"‚úÖ All stands have valid confidence and coordinates")
    
    # Test 4: Validate hunt schedule
    hunt_schedule = prediction.get('hunt_schedule', [])
    if len(hunt_schedule) > 0:
        print(f"‚úÖ Hunt schedule generated with {len(hunt_schedule)} time slots")
        
        for slot in hunt_schedule:
            # Check required fields for hunt schedule
            required_fields = ['time', 'hour', 'top_three']
            for field in required_fields:
                if field not in slot:
                    print(f"‚ùå Hunt slot missing {field}")
                    return False
            
            # Check that top_three has stands with wind info
            top_three = slot.get('top_three', [])
            if len(top_three) > 0:
                for stand in top_three:
                    if 'wind_favorability' not in stand:
                        print(f"‚ùå Hunt schedule stand missing wind_favorability")
                        return False
                
        print("‚úÖ Hunt schedule has valid structure")
    else:
        print("‚ö†Ô∏è No hunt schedule generated")
    
    # Test 5: Check for deer activity zones
    activity_zones = ['bedding_zones', 'feeding_areas', 'travel_corridors']
    zones_found = 0
    for zone_type in activity_zones:
        if zone_type in prediction and prediction[zone_type].get('features'):
            zones_found += 1
            zone_count = len(prediction[zone_type]['features'])
            print(f"‚úÖ {zone_type}: {zone_count} areas identified")
    
    if zones_found == 0:
        print("‚ö†Ô∏è No deer activity zones identified")
    else:
        print(f"‚úÖ Found {zones_found}/3 types of deer activity zones")
    
    # Test 6: Validate scouting points (if present)
    suggested_spots = prediction.get('suggested_spots', [])
    if len(suggested_spots) > 0:
        print(f"‚úÖ {len(suggested_spots)} scouting points generated by backend")
        
        # Note: Frontend filters these to 7.5+ threshold, so backend may have lower ratings
        high_quality_spots = [spot for spot in suggested_spots if spot.get('rating', 0) >= 7.5]
        if len(high_quality_spots) > 0:
            print(f"‚úÖ {len(high_quality_spots)} high-quality scouting points (7.5+)")
        else:
            print("‚ÑπÔ∏è No high-quality scouting points (will be filtered by frontend)")
    else:
        print("‚ÑπÔ∏è No scouting points generated by backend")
    
    print(f"‚úÖ {location_name} passed all logic validation tests!")
    return True

def main():
    """Run comprehensive prediction logic tests"""
    print("üéØ DEER PREDICTION ALGORITHM VALIDATION")
    print("=" * 50)
    
    # Test Vermont locations with different characteristics
    test_locations = [
        {
            "name": "Green Mountain National Forest (High elevation)",
            "lat": 43.1687,
            "lon": -72.8092,
            "season": "rut"
        },
        {
            "name": "Lake Champlain Valley (Agricultural area)",
            "lat": 44.4759,
            "lon": -73.2121,
            "season": "early_season"
        },
        {
            "name": "Northeast Kingdom (Mixed forest)",
            "lat": 44.6378,
            "lon": -72.0145,
            "season": "late_season"
        },
        {
            "name": "Southern Vermont (Rolling hills)",
            "lat": 43.0642,
            "lon": -72.6874,
            "season": "rut"
        }
    ]
    
    print("Starting backend container for testing...")
    os.system("cd c:\\Users\\Rich\\deer_pred_app && docker compose up backend -d")
    
    import time
    print("Waiting for backend to start...")
    time.sleep(5)
    
    passed_tests = 0
    total_tests = len(test_locations)
    
    for location in test_locations:
        prediction = test_api_endpoint(
            location["lat"], 
            location["lon"], 
            location["season"]
        )
        
        if validate_prediction_logic(prediction, location["name"]):
            passed_tests += 1
    
    print("\n" + "=" * 50)
    print(f"üéØ TEST RESULTS: {passed_tests}/{total_tests} locations passed validation")
    
    if passed_tests == total_tests:
        print("üéâ ALL PREDICTION ALGORITHMS ARE WORKING CORRECTLY!")
        print("‚úÖ Logic validation passed for all Vermont locations")
        print("‚úÖ Stand recommendations are reasonable")
        print("‚úÖ Hunt schedules are properly generated")
        print("‚úÖ Deer activity zones are being identified")
        print("‚úÖ Scouting points meet quality thresholds")
    else:
        print("‚ö†Ô∏è Some algorithms may need attention")
        failed = total_tests - passed_tests
        print(f"‚ùå {failed} location(s) failed validation")
    
    print("\nStopping backend container...")
    os.system("cd c:\\Users\\Rich\\deer_pred_app && docker compose stop backend")

if __name__ == "__main__":
    main()
